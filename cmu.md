# 第一节存储引擎

### 基于磁盘的提议结构

数据库管理系统需要数据库的存储都落在非易失的磁盘上。

### 数据库的数据流动

![1694225725817](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694225725817.png)

### 随机存储vs顺序存储

随机存储通常比顺序存储更慢。

数据库管理系统希望尽可能最大化顺序访问。

存储算法应尽可能减少大量的随机存储写从而使数据大量顺序存储。

### 系统设计目标

允许数据库管理系统管理数据库超出内存的存储。

读写磁盘的代价是巨大的，所以通常避免经常读取磁盘的操作。

### 为什么不使用操作系统去管理？

![1694227879303](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694227879303.png)

![1694228191783](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694228191783.png)

DBMS可以比OS更好地管理：

管理脏页读写；预先读；缓冲替换策略；线程预定。

mmap方法当磁盘读取页数超出物理内存页数时，操作系统不知道，会卡住，且并发写时也会出问题。

madvise：告诉os你当前期望读取哪些页数。

mlock：告诉os内存哪些页数不能被弄出内存。

msync：告诉os内存哪些页数可以被弄出内存。

### 数据库存储两大问题

#### 1 DBMS怎么管理数据库的数据落在磁盘上的表示？

##### 文件存储

DBMS存储数据库在磁盘上以专门的格式形成一个或多个文件，且OS不知道这些文件的目录情况。

存储管理器：存储管理器负责维护数据库的文件，有时候做自己的读写磁盘的调度，以提高页面的空间和时间局部性。它也可以为文件组织为页面的集合，跟踪读写的数据，跟踪可用空间。

##### 通常一个页的大小有三种：

硬件页：4kB；（存储设备保证故障时写入的最大数据块；最小原子操作）

os页面：4kB；

数据库页：512B-16KB

##### 堆文件：一堆无序的页组成。

堆文件的两种组织形式：

链表：

![1694229745074](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694229745074.png)

有两个指针，一个指向空闲页列表的头，一个指向数据页列表的头，且每个页面会跟踪他们当前有多少空闲槽。

页目录：

![1694229894406](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694229894406.png)



##### 页布局

![1694229999570](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694229999570.png)

checksum：检验码

有系统要求页自解。

两种存储数据到页的方法： 

Tuple-oriented：只存数据；

![1694230441106](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694230441106.png)

slotted pages：解决了tuple-oriented的数据必须有序的问题。

![1694230581064](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694230581064.png)

追踪元组的方式：给每个元组设置一个独一无二的身份id，通常是page_id+offset（偏移量）/slot。

外部应用不能用这些id去追踪元组

Log-structured：存log。

![1694438936937](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694438936937.png)

只记录最后的状态。修改log相当于插入新的数据。

压缩原则：把多个日志压缩成最少反映数据的情况。

![1694439576139](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694439576139.png)



##### 元组布局 

元组就是一组有序的字节组成；DBMS的工作是将这些字节解释为属性类型和值。

![1694230857428](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694230857428.png)

data representation

mysql的数据表示形式：

![1694440100352](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694440100352.png)

为了存储比一个页更大的数据时，DBMS有时候会用分离的益处存储页

![1694440390793](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694440390793.png)

数据库工作负载：

OLTP（在线交易处理）：短时间处理小数据量。用户用。按行存储的数据适合OLTP

行存数据优点：便于插入删除。

缺点：扫面数据时很容易做无用功 

列存数据优点：查询数据时磁盘i/o减少，容易数据压缩。

缺点：删除插入更新时会分裂。OLAP适合用列存储。

![1694441459927](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694441459927.png)

OLAP（在线分析处理）：处理大量数据。公司用

![1694441479154](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694441479154.png)



system catalogs



storage models

tuple identification：

offsets：空间开销小，但需要算偏移量。

tuple id：空间开销大。

![1694442144238](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694442144238.png)

# 第二节缓存池

缓存的作用：将磁盘的数据缓存到其中；缓存要写回磁盘的数据；延迟写；预先读 

缓存池组织：一帧缓存一页。

给内存页加锁，防止被清除掉。

Lock：逻辑抽象上的锁

![1694444339187](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694444339187.png)

Latch（Mutex）：具体底层的锁

![1694444376193](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694444376193.png)

Page Table：

内存池里面的索引。

Page Directory：

磁盘里面的索引。

缓存分配策略：

全局策略；本地策略：

有存索引的元数据的数据的三种缓存池，可以防止冲突。

识别缓存池：识别object id；做哈希。降低锁的冲突和竞争。

同步扫描：我们把扫描的结果共享。

![1694447700214](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694447700214.png)

轻扫描：只读一次的或者暂时使用的数据或中间数据不读入缓存池。

![1694447716593](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694447716593.png)

绕过os缓存：可以防止冗余的页产生；防止丢失对i/o的掌握。

页的替换策略：正确性；精确性；速度；元数据开销（meta-data overhead）

lru和clock只能替换最老的页，并不能替换最有用的页。

lru-k：看前面几次是什么时候读的。

localization：本地的替换，别人的不轻易替换。

priority hints：优先级

脏页：如果内存以后不会用到，写回去。

缓存池其他缓存的东西：

![1694447624829](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694447624829.png)



####  DBMS怎么管路数据库的数据在内存和磁盘上的移入移除？

# 第三节哈希表

哈希表设计目的：

1数据组织：如何在页面/内存中布局数据结构，以及存储哪些信息支持高效访问。

2并发性：支持多个线程同时访问数据结构而不产生问题。

哈希表设计目标：

1哈希函数：如何将一个大的键空间映射到较小的域；快速与碰撞率之间的权衡。

2哈希方案：如何处理哈希键后的键冲突；查找插入键的指令。

通常不使用加密（cryptographic）的哈希函数。对于哈希函数尽可能碰撞率低且速度快。

一些典型的哈希函数：

![1694486793246](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694486793246.png)



静态的哈希数据结构：

1线性探测哈希：

非唯一键设置：

（1）单独的链表：为每个键在单独的存储区域存储值。

（2）冗余密钥：将重复的键项存储在哈希表中。

2robin hood hashing：

![1694487477526](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694487477526.png)

在插入时，如果第一个键比第二个键离最佳位置更远，则该键占用另一个键的槽位；每个键都追踪自己来自位置数它在表中的最优位置。

3cuckoo hashing：使用不同哈希函数种子的多个哈希表；在插入时，检查每个表，跳出空闲槽的表，如果没有表有空闲槽，从其中一个表中取出该元素，然后在新的位置重新哈希，查找和删除总是o（1），因为每个哈希表只检查一个位置。

静态结构的缺点：静态哈希表必须要求DBMS知道他想要存储的元素的数量，否则是重建时要增大缩小它的大小。

动态哈希表：

1chained hashing：维护哈希表中每个槽的桶链表；通过将所有具有相同哈希键的元素放入同一个桶中来解决冲突；确定一个元素是否存在，向他的桶散列并扫描它。

2 extendible hashing：链式哈希方法，我们将桶拆开，而不是让链表永远增长；多个槽位置可以指向同一个桶链；对分裂的桶链重新洗牌，增加要检查的比特数，数据移动只局限在分割链上

![1694489444374](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694489444374.png)

3 linear hashing：哈希表维护一个指针，跟踪下一个要分割的桶。在任何桶溢出时，在指针位置拆分桶，使用多个哈希来为给定的键找到正确的桶。可以使用不同的溢出准则：空间利用率，溢出链平均长度。当分家指针移到最后一个时，最后移回去。

![1694490562076](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694490562076.png)

# 第四节索引并发

并发控制协议方法：是DBMS用来确保共享对象上并发操作的正确结果的方法。

逻辑正确性：线程能看到它数据的正确性。

物理正确性：对象的内部表征正确。

LocksVSLatches

![1694518846936](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694518846936.png)

Latch Modes：read；write

Latch Implementions（实施方法）：

方法一：Blocking OS Mutex

特点：简单易实现；无法应对大规模线程竞争场面

方法二：Test-and-Set Spin Latch（自旋锁）

特点：高效；也无法应对大规模线程；对缓存和操作系统都不友好；原子操作

方法三：Reader-Writer Latcher

特点：适用于并发进程；管理读写队列避免饥饿；安装在自旋扣上。

哈希表锁：由于线程访问数据结构的方式有限，支持并发访问；所有线程都向同一个方向移动，一次只访问一个页面；不可能发生死锁。page latches；slot latches；

哈希无锁插入算法：将内存位置M的内容与给定值V进行比较的原子指令，如果值相等，则在M中安装新的给定值，否则，操作失败。

B+树并发操作的两个问题：线程修改节点内容时要避免同一时间；一个线程遍历树时，另一个节点拆分节点。

解决方法：螃蟹锁：该方法允许多个线程同时修改/访问b+tree。

基本思想：先给父节点上锁，在给孩子上锁，当父母安全时，释放锁，一个节点安全指节点更新时不会分裂或合并节点。

找节点：先从根开始，往下走，反复

删除节点：从根节点开始，一旦子节点锁住，检查是否安全，如果安全，释放祖先节点锁存器。

b+树加锁会发生死锁所以应该制定一些规则

better latching 算法：祖先节点加读锁，子节点加写锁

# 第五节B+树

建立索引要平衡存储开销和维护开销。

B+树是一种自平衡数据结构，他保持数据排序，并允许在olog(n)内进行搜索、顺序访问

插入和删除。每个有k个键的节点有k+1个非空子节点。出跟节点外的每个节点至少是半满的。M/2-1《=keys《=M-1.中间节点是下一层的地址。叶节点是下一层的id或地址。

优势：一个节点为一个页。

![1694575474881](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694575474881.png)

B+树叶节点值：

方法一：记录id：指向索引项所对应的元组位置的指针。

方法二：元组数据（主键索引）：叶节点存储元组的实际内容；二级索引必须存储record id作为它们的值。

B+树如何存储重复键：

方法一：附加记录ID：添加元组的唯一记录作为ID键的一部分

![1694576374780](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694576374780.png)

方法二：OverFlow叶节点：允许叶节点溢出到重复键的溢出节点中

![1694576414763](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694576414763.png)

聚簇索引：遍历方便；早物化

![1694576621526](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694576621526.png)

非聚簇索引：会导致数据混乱 解决方法：先明白数据在哪个页

![1694576568695](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694576568695.png)

B+树节点大小：磁盘速度越低，节点应该越大；随机遍历越多，节点应该越小

最好的大小取决去开销：

Leaf Node Scans：大节点

Root-to-Leaf Traversals：小节点

节点合并阈值：延迟合并可以降低B+树重新组织时间

如何解决变长的Keys:

方法一：存索引值的指针

方法二：B+树节点本身变长

方法三：补字节

方法四：存槽，槽指向数据 

方法五：定数量

节点内部搜索

方法一：线性搜索

方法二：折半查找

方法三：插值：基于已知键的分布，得到所需键的近似位置。

![1694577490078](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694577490078.png)

B+树优化：

前缀压缩

![1694577546353](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694577546353.png)

防冗余：

![1694577593896](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694577593896.png)

按批插入：先将数据弄成B+树，在插入到B+树中

# 第六节排序和聚集

外部归并排序：先分块排序，再归并排序

早物化：整个元组排好

晚物化：id排序好

![1694621207070](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694621207070.png)

二路归并排序只需要三个缓冲页来执行排序，二个输入页一个输出页，即使我们有多的缓冲页，我们也不能有效利用他们。

外部散列聚集：

步骤一：Partition：先将元组分割成多个位于磁盘上的分区

步骤二：Rehash：磁盘里面的哈希表太大且冲突太多

# 第七节连表算法

为什么需要连表？

我们将关系数据库中的表现泛化从而避免不必要的重复信息，使用连接运算符重建的元组，没有任何信息丢失。

连接算法中，我们将较小的表格始终是查询计划中的左表。

连接输出的内容取决于：加工模型；存储模型；查询的数据要求。

早物化：数据连接后全部输出。将外部元组和内部元组中的属性复制到一个新的输出元组中。

![1694660842792](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694660842792.png)

晚物化：只复制连接键和匹配元组的id。

![1694661061842](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694661061842.png)

JOIN VS CROSS-PRODUCT

![1694661857452](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694661857452.png)

Nested Loop Join（嵌套循环连接）：Simple：

![1694662402990](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694662402990.png)

Block：![1694662330228](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694662330228.png)

1. 先把r第一页放进来，再把s第一页放进来，再页内部遍历匹配，再把S表的第一页淘汰掉。

2.一个页用于缓存输出，一个页作为内标缓存，其他页均作为外表缓存。

嵌套循环糟糕的原因：对于外部表中的每个元组，我们都必须要顺序扫描来检查内部表中的匹配，因此我们可以使用索引来避免顺序扫描。

Index：

![1694663151233](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694663151233.png)

外表缓存越多，内标遍历越少

Sort-Merge Join：

步骤一：排序：根据连接键对两个表进行排序

步骤二：归并：将两个带游标的排序表调试好。有时需要回溯

![1694663500443](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694663500443.png)

当输出需要有序时，归并排序更有用。

Hash Join：外表哈希表，内标遍历。

哈希表值：方法一：全元组：避免必须匹配检索外部关系的元组内容；占用更多空间

方法二：元组标识符

grace hash join：外表和内表都做哈希表，放在磁盘中，需要时在读进内存

![1694705753527](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1694705753527.png)

# 第八节查询执行

处理模型：DBMS的处理模型定义了系统如何执行查询计划-争对不同的工作负载进行不同的权衡。

方法一：迭代器模型

每一个查询计划操作符实现一个next（）函数，每次调用时，操作符返回单个元组，如果没有更多的元组，则返回空标记。操作符实现一个循环，调用其子元素next（）来检索他们的元组，然后对他们进行处理

![1695046044795](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695046044795.png)



![1695046024839](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695046024839.png)

一些操作符必须阻塞，直到他们的子操作符发出所有的元组(join,subqueries,order by)

特点：几乎在每个DBMS中使用。允许元组管道

方法二：物化模型方法

每个操作符一次性处理他的所有输入，然后一次性发出它的所有输出。运算符将其物化为单个结果；输出可以是整个元组，也可以是列的子集。

![1695046950368](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695046950368.png)

更适合OLTP工作负载，因为查询一次只需要访问少量元组

方法三：批处理模型

就像迭代模型。每个操作符实现一个next()函数，但是每个操作符发出一批元组，而不是单个元组，操作符的内部循环一次处理多个元组，批处理的大小可以根据硬件或查询属性而变化

![1695047268846](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695047268846.png)

特点：理想的OLAP查询，大大减少了每个操作符的调用次数；允许运算发更容易地矢量化指令来处理批量元组。数据库计划处理方向：

方法一：从上到下：从根开始，从他的子节点上拉数据；元组总是随函数调用一起传递

方法二：从低岛上：从叶节点开始，将数据推送到他，恶魔的父节点，允许更严格地控制管道中的缓存寄存器。

存取表方法

顺序存取：优化：预读取；不进缓存，直接执行；并行；堆聚类；zone maps；晚物质化

zone maps：给每个页做统计信息，好处：读取某些信息不用读页直接读统计信息即可 缺点：页的信息可能会改变，浪费内存

![1695048107081](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695048107081.png)

索引扫描：读取的速度索引包含哪些属性；查询引用什么属性；属性的值域；谓词组合；索引是否是唯一键或非唯一键

多索引扫描：

![1695048633513](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695048633513.png)

更改查询： 

update/delete：子操作符传递目标元组的id，必须跟踪见过的元组。

insert：在操作符内部实现元组；操作符插入从子操作符传入的任何元组。

万圣节问题：一个更新操作改变了元组的物理位置，导致扫描运算符多次访问元组的异常；可能发生在集群集或索引扫描上。

并行数据库：资源在物理上彼此靠近，资源通过高速互联互通，通信廉价

分布式数据库：把数据库切成多个节点，用户连接一个节点即可；资源之间可能相聚较远；通信之间使用慢速互联；

进程模型：DBMS的进程模型定义了系统的架构如何支持来自多用户应用程序的并发请求；worker是负责客户端执行任务并返回结果的DBMS组件（每个worker都是独立的OS进程：依赖于OS调度程序；对全局数据结构使用共享内存；进程崩溃不会使整个系统崩溃）

worker吃资源，把worker变成池：工作进程使用池的任何空闲进程，仍然依赖于操作系统调度程序和共享内存，对cpu缓存局部性不好。

每一worker线程数：具有多个工作线程的单个进程：DBMS管理自己的调度，可以或不可以使用分派器线程，线程崩溃会杀死整个系统。

线程模型优点：切换开销小；不要考虑通信。

查询间并发处理：不同查询并发查询；增加吞吐量和降低延迟

查询内部并发处理：一个执行计划切成多个线程。

查询间处理器并行性：

水平行：将运算符分为独立的片段，在不同的数据子集上执行相同的功能；DBMS在查询计划中插入一个交换操作符来合并/拆分来自多个子/父操作符的结果。

交换算子

![1695092286173](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695092286173.png)

垂直性：操作是可以重叠的，以便将数据从一个阶段输送到下一个阶段，而不是具体化；worker同时执行来自查询计划的不同段的操作符，也成为管道并行

![1695092765735](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695092765735.png)

浓密的并行性：操作符内并行和操作符间并行的混合，worker同时执行来自查询计划的不同段的多个操作符；仍然需要交换运算发组合来自不同段的中间结果

i/o并行性：将DBMS拆分到多个存储设备上：每个数据库多磁盘，一个磁盘一个数据库，每个磁盘一个关系，跨多磁盘的分裂关系。

数据库分区：将单个逻辑表拆分为分离的物理段，这些物理段单独存储/管理。分区对应用程序是透明的，应用程序只访问逻辑表，而不必担心事物的物理存储方式。

水平分区；垂直分区

# 第九节查询优化

查询优化启发式/规则：重写查询要删除愚蠢/低效的东西；技术可能需要检查目录，但不需要检查数据。

基于成本的搜索：使用模型来估算执行计划的成本；评估一个查询的多个等效计划，并选择成本最低的计划。

应用请求数据库流程：

![1695141720742](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695141720742.png)

tree rewriter：正则语法器

逻辑计划：优化器生成一个逻辑计划的映射，是从代数表达式到最有等价物的物理代数表达式。

物理计划：物理运算符使用访问路径定义特定的执行策略，他们可以依赖于他们处理的数据的物理格式，逻辑到物理并不总是1比1的映射。

查询优化是一个NP问题（没有一个最优的结果）

关系表达式的等价：如果两个关系表达式输出的结果是一样的，则这两个关系表达式等价。

![1695142280348](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695142280348.png)

这两个关系表达式等价，但下面这个查询更高效。

投影优化：只管查询的那一列；先查最后在回头看。

逻辑计划优化：使用模式匹配规则将一个逻辑计划转换为一个等价的逻辑计划。目标是增加在搜索枚举最优计划的可能性。

常用规则如下：分离连接谓词

![1695142775173](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695142775173.png)；谓词下推

![1695142794506](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695142794506.png)

；连接投影下推

![1695142830856](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695142830856.png)

；代替笛卡尔积

![1695142818294](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695142818294.png)

嵌套子查询：DBMS将where子句中的嵌套子查询视为接受参数并返回单个值或一组值的函数。

两种方法：重写以去关联或平坦他们；分解嵌套查询并将结果存储到临时表中

表达式重写：使用if/then/else子句或模式匹配规则引擎实现，搜索与模式匹配的表达式，找到匹配项后，重写表达式

基于代价的查询优化：

物理代价：cpu以及i/o开销；跟硬件关系很大；

逻辑开销：争对算子，做出估算

算法开销：时间复杂度

一般都是磁盘开销最大

![1695144105737](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695144105737.png)

统计信息：对于每个关系R，DBMS维持以下的信息：NR：R关系里面的元组数量；

V（A，R）：属性A中不同值的个数

S（A，R）：一个属性值的平均数

![1695178938847](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695178938847.png)

用该表估计连接的值有多大

选择基数：

假设一：数值的分布（除了重量级属性）是相同的

假设二：属性上的谓词是独立的

假设三：连接键的域重叠，使得内部关系的每个键也存在与外部表中

![1695179639161](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695179639161.png)

这种图存储可能需要消耗大量内存

等宽直方图：

![1695179616602](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695179616602.png)

问题：可能丢失较多信息，带来误差

等身直方图：

![1695179719200](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695179719200.png)

草图：不记录具体的数据，记录数据的概率统计，用成本模型可以用草图代替直方图，以提高选择性估计精度

count—minsketch：集合中元素的近似频率个数。

HyperLogLog：近似一个集合中不同元素的数量。

在基于规则的重写之后，DBMS将枚举查询的不同计划并估计他们的成本：单一的关系；多重关系；嵌套的子查询。在耗尽所有计划或有时超时时，查询选择他所有的最佳计划。

单表查询：选择查询方法；谓词调整

多表查询：主要寻找降低搜索空间，system r的决策时只考虑左连接树（允许完全流水线的计划，中间结果不写入临时文件，但不是所有的左深树都是完全流水线），通常列举一些计划，比如左深树顺序，算子的实现方案，表的连接方案



![1695181688301](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695181688301.png)

剪枝：剪去代价大的

![1695181839528](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695181839528.png)

![1695181850632](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695181850632.png)

![1695181868740](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695181868740.png)

尽量选择选择性大的谓词；连接顺序通常会用动态规划

# 第十节并发控制理论

事务是一系列的sql语句来达到高级操作。

稻草人系统：每个TXN到达DBMS时逐一执行。同时有且仅有一个TXN可以同时在DBMS执行。在TXN启动之前，将整个数据库复制到一个新文件中，并对改文件进行更改。如果TXN成功完成，用新文件覆盖原文件，如果TXN失败，直接删除脏拷贝即可。

一个潜在更好的方法时允许独立事务的并发执行。

任意交错操作可能导致：临时不一致；永久不一致。

SQL的事务：新的txn以begin命令开始。txn以commit或者abort命令停止。如果提交，DBMS要么保存TXN的所有修改，要么中止TXN。如果arbot，所有的修改都被撤销，就像txn从来没有执行过一样。中止是可以造成的，也可以是DBMS造成的。

事务正确性（acid）：

原子性：事务要么都成功执行，要么都不执行。

如何保证事务的原子性：

1日志：记录修改的数据，随时回滚；还可以进行审计

2备份

一致性：做完事务后，状态应该一致。

时间一致性：后面的事务能看到前面事务产生的影响。

事务一致性：数据库在事务开始之前是一致的，那么他之后也是一致的。由应用程序负责

隔离性：事务之间相互不影响。

确保隔离的机制：

并发控制协议是DBMS如何决定多个事务中操作的适当交错；有两类协议：悲观：一开始就不让问题出现；乐观：假设冲突很少发生，在冲突发生后处理

持续性：事务完成后，数据库的更新是永久的。

用户可以利用冲突来判断schedule是否可串行化。

依赖图：![1695316615993](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695316615993.png)

如果一个调度的依赖图是无循环的，那么他的冲突就是冲突序列化的

![1695316736460](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695316736460.png)

发生了冲突。

![1695316855312](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695316855312.png)

没发生冲突，等效于T2小发生

![1695317141643](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1695317141643.png)

正确执行。

基于观察和基于依赖图都不能正确判断。

# 第十一节两阶段锁

基本锁的类型：

S锁：共享锁

X锁：排它锁

![1697031064445](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1697031064445.png)

不能解决可串行化的问题

二阶段锁是一种并发控制协议，他决定了一个动作是否可以动态访问数据库中的对象。且协议不需要提前知道事务将执行的所有查询。

第一阶段：增长阶段：在这个阶段只能给事务加锁

第二阶段：收缩阶段：边解锁边操作。

问题：无法处理级联回滚问题（当进入收缩阶段时，t1提交自己的结果，但是t2需要t1之前的结果，因此t1需要回滚，因此发生冲突）；脏读；死锁。

怎么解决脏读：严格二阶段锁：第二阶段只能解锁。

严格二阶段锁规定：如果一个事务写入的值在该事务完成之前没有被其他事务读或者写，则调度是严格的。

优点：不会引发级联中止；中止的事务可以通过修改元组的原始值来恢复。

缺点：无法解决死锁

强严格二阶段锁：

![1697033620242](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1697033620242.png)

二阶段锁

![1697033640991](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1697033640991.png)

解锁死锁：

死锁检测：看依赖图存在环吗；在通过回撤或者废除事务解决死锁

![1697034148879](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1697034148879.png)

回滚一个事务有时候只需要回滚一部分

死锁预防：根据时间戳给事务优先级。

旧的时间戳一般优先级更高。

wait-die：如果请求事务的优先级高于持有事务，那么请求事务等待持有事务。

wound-die：如果请求事务的优先级高于持有事务，持有事务直接中止并释放锁。

![1697035146454](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1697035146454.png)

锁粒度：进行并行性与开销的权衡，理想的情况下，DBMS应该获取事务所需的最少数量的锁。

通常给一个表加锁，则表下所有的元组也加锁了

意向锁：允许更高层级的部件加一些标记表示下层的部件可能会被加锁。

IS：下部件可能加了共享锁。以更细的粒度获取共享锁。

IX：下部件可能加了排它锁。以更细的粒度获取排他锁。

SIX：共享锁锁了整个表，下部件加了排它锁。同时像s和ix锁

![1697035751171](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1697035751171.png)

每个事务在数据库层次结构的最高层获得适当的锁。

![1697035914960](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1697035914960.png)

锁升级：当获得太多低级锁时，会动态请求加粗锁粒度

# 第十二节时间戳顺序并发控制

时间戳的分配：每个事务被分配一个唯一的固定时间戳，该时间戳单调递增。

多种实现策略：系统时钟；逻辑计数器；混合动力车。

基础时间戳顺序并发控制方法：事务进行读写操作时不用加锁。

W-TS(X):事务在最后一次写时的时间戳

R-TS(X):事务在最后一次读时的时间戳。

问题：备份数据到事务的工作空间和更新时间戳的开销；长时间的事务可能会饿死。

当对未来数据操作时，事务停止重新开始

![1697118427430](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1697118427430.png)

托马斯写规则：

![1697119068814](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1697119068814.png)

忽略写，允许事务继续执行而不中止。不使用托马斯写规则，会没有死锁；但段事务一直引起冲突，长事务可能会饿死

当事务只有在读取所有事务修改后才提交，那么一个时间表是可恢复的。否则，DBMS不能保证事务读取的数据将在崩溃后恢复。

假设事务之间的冲突很少，并且都是一些短事务，强迫事务等待获取锁会增加很多开销。更好的方法是针对无冲突的情况进行优化。

乐观并发控制：DBMS为每个事务建造一个私人的空间，任何读取的对象后会被复制到工作区，修改也同样应用于工作空间。当一个事务提交时，DBMS比较工作空间写集，看他是否与其他事务冲突。

三步骤：

读步骤：跟踪事务的读/写集。并将他们的写操作存储在一个私有的工作区中。(在写阶段时，只能有一个事务)

验证步骤：当某个事务提交时，检查是否与其他事务冲突。当事务调用commit是，给事务时间戳，DBMS检查它是否与其他事务冲突

编写步骤：如果验证成功，对数据库应用私有更改，否则，中止重启事务。

向后验证：检查事务的读写集是否与任何已经提交的事务读写集相交。

向前验证：看提交的事务和任何尚未提交的活动事务的读写交集相交。

occ：适用于冲突少的和只读事务的。

性能问题：在读写阶段时，复制数据高开销；校验有瓶颈；出问题时提交时，之前所做的事全部中止。

如何解决幻读？

RE-EXECUTE SCANS:记录所有可能幻读的地方。

PREDICATE LOOKING：在select语句加共享锁；update，insert，delete语句加排它锁。

INDEX LOOKING：谓词有索引就锁索引。如果没有索引所有表都加。

可序列化很有用，但是他会限制性能，我们可能希望使用较弱的一致性来提高性能。、

隔离级别：![1697187648437](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1697187648437.png)

![1697187665155](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1697187665155.png)

![1697187703366](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1697187703366.png)

# 第十三节多版本并发控制

DBMS在数据库中维护单个逻辑对象的国歌物理版本：当事务写入对象时，DBMS创建该对象的新版本。当事务读取一个对象时，它读取事务启动时存在的最新版本。

MVVC(多版本并发控制)：写不会阻塞读，都不会阻塞写。只读事务可以在不获取所得情况下读取一致性快照。使用时间戳来确定可见性。

只依赖MVCC 不能解决可串行化问题。

并发控制手段： 

方法一：与时间戳进行结合，给事务分配时间戳来确定序列顺序。

方法二：乐观并发控制。

方法三：二阶段锁。

新老版本存储：使用链表来记录每一个版本号。不同存储方法决定怎么存储。

方法一：追加

![1698158188791](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1698158188791.png)

可以新的放在末尾或头部。

方法二：主表与历史表

每次更新时，将当前版本复制到时间旅行表中，更新指针。覆盖主表中的master版本，更新指针。

方法三：增量存储

只存储历史和现在版本的增量

![1698160018733](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1698160018733.png)

垃圾回收：

随着时间版本的推移，DBMS需要从数据库删除可回收的物理版本，DBMS中没有活动的事务可以看到该版本，该版本是由一个已中止的。

方法一：以行记录为单位的垃圾回收。

后台清理：单独的线程定期扫描表，寻找可回收的版本。

合作清理：干活的线程顺便做垃圾清流。

方法二：以事务为单位进行回收。

每个事务跟踪其读写集。DBMS决定何时有已完成的txn创建的所有版本不可再见，可能需要多个线程以足够快的速度为工作负载回收内存。

多版本索引管理：主键索引指向版本链头，DBMS更新主键索引的频率取决于当元组更新时系统是否创建了新版本，如果一个事务更新了一个元组的主键属性，首先删除后插入。

辅助索引：

方法一：逻辑指针：每个元组有个固定的标识符，不会改变；需要额外的间接层；记录主键与元组id

方法二：物理指针：使用版本链头的物理地址。

MVCC索引：通常不存储元组及其键的版本信息；每个索引必须支持来自不同快照的重复键；同一个键可以在不同的快照中指向不同的逻辑元组。每个索引的底层数据结构必须支持非唯一键的存储。使用额外的执行逻辑来执行主键的条件插入。工作线程可以在一次读取中获取多个条目。然后遵循指针来找到正确的物理版本。

MVCC删除：只有当逻辑删除元组的所有版本不可见时，DBMS才从数据库中物理删除元组。如果一个元组删除，那么该元组在最新版本之后就不能再有新版本了。

方法一：加个删除标识：表示逻辑元组在最新的物理版本之后已经被删除。

方法二：墓碑：表示删除一个逻辑元组。

# 第十四节数据库日志

恢复算法是确保数据库一致性，事务原子性已经故障持久性的技术。有两个部分：正常处理事务期间的操作，确保DBMS可以从故障中恢复；将数据库恢复到确保原子性、一致性和持久性的状态失败后的操作。

崩溃恢复：DBMS根据底层存储设备分为不同的组件——易失性和非易失性，还要对不同类型的故障进行分类。

故障分类：

1事务级故障：逻辑错误：某些内部条件错误，如违反完整性约束，事务无法完成；

内部状态错误：死锁。

2系统故障：软件故障：软件发生故障；

硬件故障：硬件损坏。

3存储设备故障

数据库需要确保数据一旦提交就不能改变；事务被中断掉要撤销之前做的操作。

undoVSredo：

undo：删除未完成或终止的事务的影响的过程。

redo：恢复已提交的事务的持久性的过程。

窃取策略：DBMS是否允许别的未提交的事务覆盖非易失性存储对象的最近提交值。

强制策略：是否强制用户刷脏数据到磁盘去。

no-steal+force：受到磁盘大小的限制。

![1698252423007](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1698252423007.png)

![1698252512057](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1698252512057.png)

优点：永远不必因为更改没有写入磁盘而撤销已终止事务的更改；永远不必重做已提交事务的更改，因为所有的更改在提交时已被写入磁盘。

影子页：维护两个独立的数据库副本：事务只在影子副本中进行更新，事务提交时，会将影子版本换成新的主副本。

master：只包含提交事务的更改；

shadow：包含未提交事务所做的更改的临时数据库。

undo：只删除影子页；

redo：不用做啥。

问题：拷贝开销大；容易数据碎片化。

预写日志：先写日志，再写数据。采用steal+noforce策略。

![1698254399357](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1698254399357.png)

物理日志：在数据库中记录对特定位置所作的更改。

空间开销大。

逻辑日志：事务的高级操作。

混合日志：记录页几号槽指向的数据变化。

![1698255013374](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1698255013374.png)

# 第十五节数据库恢复

checkpoints：防止日志过长。周期性做些存档工作。新来的事务不开始，旧事物截止。

![1698302394510](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1698302394510.png)

ARIES:数据库恢复原型算法：用预写日志方法，缓存池策略用STEAL+NO-FORCE。在数据库档期恢复时候，利用wal恢复。需要回滚的日志回滚。

预写日志记录:每个日志给个序列号（LSN），表示系统运行的状态。

![1698302940317](C:\Users\王黎超\AppData\Roaming\Typora\typora-user-images\1698302940317.png)

flushedlsn：哪些日志写进磁盘。pagelsn有关页都刷入磁盘，表示安全。如果有glushedlsn后的页没保存，则不能写入磁盘。

事务提交时：将commit记录写入日志，将所有日志记录知道事务的commit记录都被刷新到磁盘。提交成功时，写一条特殊的TXNEND记录到日志中。

事务中止：中止一个事务是ARIES撤销操作中应用于一个事务的特殊情况，我们还需要再日志记录中添加另一个字段：事务前一个LSN，维护每一个链表，方便遍历他的记录。

清空日志：清空日志描述了撤销前更新记录的操作。它具有更新日志的所有字段加上unonext指针（下一个要撤销的LSN），通知事务中止之前不会等待他们被刷新。